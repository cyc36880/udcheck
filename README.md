## udcheck 数据包

一个完整的数据包，包含以下元素

`包头` + `包长` + `数据包` + ... + `数据包` + `和校验`



| 类型   | 解释                                                         |
| ------ | :----------------------------------------------------------- |
| 包头   | 默认以`0xFA`为起始（没什么根据，仅仅是第一次写这个库一直保留下来的习惯），可以自行更改，可以多字节 |
| 包长   | 记录整个包的长度，由两个字节表示。大端模式（高字节在前，低字节在后）。数值为`包长`后面字节一直到结尾的字节数 |
| 数据包 | 个数据包由 `id` + `数据长度` + `数据` 组成。<br />其中，id由一个字节组成。在范围为0-119或120-239，240-255保留由系统使用。（其实最终都被表示为范围在`0-119`的id）当id在 `0-119` ，表示后面的数据长度较短，及`数据长度位`由一个字节表示，及数据的最大字节数为255。<br />当id在`120-239` 之间时，实际id为减去120。表示后面的数据长度较大，`数据位由两个字节表示`，采用大端模式。<br />\* 注：id为0表示后面没有数据 |
| 校验   | 采用一位和校验，从包头一直加到校验位前。校验方式内部可修改   |



## 新修订协议注意

- 目前库允许创建多个协议包句柄，且允许不同的协议包拥有不同的 `包头`。当不同的协议数据的接收在不同的接收函数中，即如协议1的接收在uart1的接收中断中，协议二的接收在uart2的接收中断中，这是不会有任何干扰的。但是当使用不同的数据包头来实现最简单的相同处理来的不同端口，如协议一以"UDC1"做为包头，协议二以"UDC2"作为包头，它们的接收中断都在uart1的接收中断中，这也可以正常使用；但是当包头的前几位重合，即协议二以“UDC12”为开头，会导致协议一错误的开始接收协议二的数据，虽然内部最终会判定接收的数据无效，但会消耗运算时间和超时时间来区分。使用时应该尽量避免这种情况。

